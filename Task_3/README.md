__**Волчкова Дарья Алексеевна  УИБО-13-24**__
__________________________________________________________
# <p align="center">Алгоритмы сортировки</p>

## Сортировка выбором (Selection Sort)
* **Определение:** на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве
* **Анализ алгоритма:**
    * Выбор минимального элемента: На каждом этапе ищется минимальный элемент из всех последующих позиций массива
    * Замена местоположением: Минимальный элемент меняется местами с текущим элементом, обеспечивая постепенное формирование отсортированного начала массива
    * Повторение процесса: Эта процедура повторяется для каждого элемента, пока весь массив не будет отсортирован
* **Производительность:** O(n²) времени, выполняется примерно n×(n-1)/2 сравнений из-за двух вложенных циклов, каждый из которых зависит от n.


__________________________________________________________
## Сортировка обменом (пузырьком) (Bubble Sort)
* **Определение:** алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
* **Анализ алгоритма:**
    * Проход по массиву: Метод пошагово перебирает элементы массива, двигаясь слева направо.
    * Сравнение соседних элементов: По очереди проверяются два соседних элемента. Если левое значение больше правого, они меняются местами.
    * Поэтапное улучшение порядка: За каждую полную итерацию самый большой из текущих элементов перемещается в конец массива («всплывает»).
    * Количество шагов уменьшается: Каждая последующая итерация проходит меньшую часть массива, так как самые большие элементы уже находятся на своих местах.
    * Завершение процесса: Итерации продолжаются до тех пор, пока весь массив не будет отсортирован, то есть все элементы окажутся в правильном порядке.
* **Производительность:**
    - Худший случай: O(n²) — массив отсортирован в обратном порядке, требуется ~n×(n-1)/2 сравнений и обменов, так как алгоритм использует два вложенных цикла
    - Средний случай: O(n²) 
    - Лучший случай: O(n) — массив уже отсортирован, срабатывает оптимизация 


__________________________________________________________
## Сортировка вставками (Insertion Sort)
* **Определение:** алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
* **Анализ алгоритма:**
    * Начало с первого элемента: Начинаем обработку со второго элемента массива (индекса 1), считая первые элементы уже отсортированными.
    * Перемещение назад: Берём текущий элемент и двигаемся назад по уже отсортированной части массива, сравнивая текущий элемент с предыдущими.
    * Сдвиг больших элементов: Если встречаемый элемент больше текущего, сдвигаем его вперёд, освобождая место для вставки текущего элемента.
    * Вставка на нужное место: Когда находим правильную позицию для текущего элемента, вставляем его туда и продолжаем дальше.
* **Производительность:**
    - Худший случай: O(n²) — массив отсортирован в обратном порядке, требуется n×(n-1)/2 операций (сравнений и сдвигов)
    - Средний случай: O(n²) 
    - Лучший случай: O(n) — массив уже отсортирован, внутренний цикл не выполняется


__________________________________________________________
## Сортировка слиянием (Merge Sort)
* **Определение:** алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
* **Анализ алгоритма:**
    * Разбиение массива: Массив рекурсивно делится пополам до тех пор, пока каждая часть не станет содержать всего один элемент.
    * Базовый случай: Одинарные элементы рассматриваются как уже отсортированные.
    * Слияние частей: Отсортированные части объединяются таким образом, чтобы результирующий массив оставался отсортированным.
    * Рекурсия и объединение: Эти этапы выполняются до тех пор, пока весь массив снова не соберётся вместе в отсортированном виде.
* **Производительность:** массив делится пополам на log n уровней рекурсии, на каждом уровне выполняется слияние всех n элементов за O(n) операций. Итого: log n × O(n) = O(n log n).


__________________________________________________________
## Сортировка Шелла (Shellsort)
* **Определение:** является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
* **Анализ алгоритма:**
    * Устанавливает: начальный промежуток (gap), постепенно уменьшающийся.
    * Частично сортирует элементы: находящиеся на расстоянии gap.
    * Завершается: обычной сортировкой вставками при gap = 1.
* **Производительность:** O(n log²n) в среднем случае для оптимальных последовательностей шагов (gaps), O(n^(3/2)) для последовательности Кнута и O(n²) в худшем случае. Сложность зависит от выбора шагов — внутренние циклы выполняются меньше операций благодаря частичной сортировке элементов на расстоянии.


__________________________________________________________
## Быстрая сортировка (Quick Sort)
* **Определение:** один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них
* **Анализ алгоритма:**
    * Выбирается опорный элемент: Обычно это последний элемент массива, хотя возможны разные стратегии выбора.
    * Разделение массива: Все элементы, меньшие или равные опорному, собираются слева от него, а большие — справа.
    * Рекурсивная обработка: Опорные элементы размещаются на своих правильных позициях, и процедура повторяется для двух получившихся подпоследовательностей.
    * Окончательное решение: После завершения рекурсий все элементы оказываются отсортированы.
* **Производительность:** O(n log n) в среднем и лучшем случае при сбалансированном разделении, O(n²) в худшем случае при выборе крайних элементов как опорных. Сложность определяется глубиной рекурсии (log n при удачном разделении, n при неудачном) и количеством операций сравнения на каждом уровне.

__________________________________________________________
## Пирамидальная сортировка
* **Определение:** алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
* **Анализ алгоритма:**
    * Создание Max-Heap: Преобразуем массив в двоичную пирамиду (max-heap), где родительские узлы всегда больше детей.
    * Удаление корней: Удаляем корень (самый большой элемент) и добавляем его в конец массива, после чего повторно формируем пирамиду.
    * Повторение: Повторяем второй пункт, пока все элементы не перейдут в отсортированное состояние.
* **Производительность:** O(n log n) — построение бинарной кучи выполняется за O(n), а n операций извлечения корня с восстановлением структуры требуют O(log n) каждая, что в сумме дает O(n log n).




<br>
# <p align="center">Алгоритмы поиска</p>


## Последовательный (линейный) поиск
* **Определение:** простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.
* **Анализ алгоритма:**
    * Последовательный просмотр: Алгоритм последовательно просматривает элементы массива, начиная с первого.
    * Проверка совпадения: Каждый элемент сравнивается с искомым значением.
    * Возврат результата: Если элемент найден, возвращается его индекс; иначе возвращаем специальный маркер (-1), означающий отсутствие элемента
* **Производительность:**
    - Худший случай: O(n) — элемент находится в конце массива или отсутствует, нужно проверить все n элементов
    - Средний случай: O(n/2) ≈ O(n)
    - Лучший случай: O(n) — элемент находится в начале массива


__________________________________________________________
## Бинарный (двоичный, дихотомический) поиск
* **Определение:** это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.
* **Анализ алгоритма:**
    * Начальная установка границ: Устанавливаем левую границу (left) равной началу массива, а правую (right) — концу массива.
    * Нахождение середины: Рассчитываем индекс центрального элемента массива (mid), используя формулу (left + right) / 2.
    * Сравнение: Сравниваем центральный элемент (arr[mid]) с искомым значением (target):
         - Если центральное значение равно цели, возвращаем его индекс.
         - Если оно больше цели, обновляем правую границу (right = mid - 1), сужая область поиска влево.
         - Если оно меньше цели, обновляем левую границу (left = mid + 1), смещая область поиска вправо.
    * Продолжение поиска: Повторяем процесс, пока границы не пересекутся (left > right), если цель не была найдена, возвращаем индикатор неудачи (-1)
* **Производительность:** O(log n), так как на каждом шаге алгоритм уменьшает область поиска вдвое путем сравнения целевого значения со средним элементом, что требует не более log₂n итераций для нахождения элемента в отсортированном массиве.


__________________________________________________________
## Интерполирующий поиск
* **Определение:** это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
* **Анализ алгоритма:**
    * Вычисление позиции: Используется формула интерполяции для оценки возможной позиции искомого элемента.
    * Сравнение: Находится ближайший элемент и сравнивается с целью.
    * Рекурсия: Если элемент не найден сразу, выполняется рекурсивный поиск либо в левой, либо в правой части массива.
    * Возвращение результата: Если элемент найден, возвращается его индекс, иначе — сигнализируется ошибка (-1).
* **Производительность:** O(log log n) в среднем случае при равномерном распределении данных благодаря предсказанию позиции элемента через интерполяционную формулу, и O(n) в худшем случае при неравномерном распределении, когда алгоритм вырождается в линейный поиск.


__________________________________________________________
## Поиск по Фибоначчи
* **Определение:** это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
* **Анализ алгоритма:**
    * Подготовка: Нахождение ближайшего числа Фибоначчи, большего или равного длине массива. Это число определяет верхнюю границу области поиска.
    * Расчёт границ: Используя числа Фибоначчи, определяются потенциальные индексы для сравнения с искомым элементом.
    * Сравнение: Текущий элемент массива сравнивается с искомым значением:
         - Если текущий элемент меньше искомого, смещаемся вправо, переходя к большему числу Фибоначчи.
         - Если текущий элемент больше искомого, смещаемся влево, переходя к меньшему числу Фибоначчи.
    * Изменение окна поиска: После каждого сравнения границы поиска сужаются, позволяя быстро приближаться к искомому элементу.
    * Окончание поиска: Цикл продолжается до тех пор, пока число Фибоначчи не сократится до 1 или пока искомый элемент не будет найден. Если элемент не обнаружен, возвращается сообщение об отсутствии.
* **Производительность:** O(log n), так как алгоритм использует числа Фибоначчи для определения точек разбиения массива, и каждая итерация сокращает область поиска через переход к меньшим числам Фибоначчи, что требует примерно log n операций.


